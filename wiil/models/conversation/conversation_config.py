"""Conversation configuration schema definitions.

Conversations represent individual interaction sessions between users and AI agents through various channels
(phone, SMS, web chat, email). They track message history, status progression, call metadata, and relationship
to deployment configurations. Each conversation is scoped to a project and organization.
"""

from datetime import datetime
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel as PydanticBaseModel
from pydantic import ConfigDict, Field

from wiil.models.base import BaseModel
from wiil.types.conversation_types import (
    ConversationDirection,
    ConversationStatus,
    ConversationSummarySentiment,
    MessageType,
    ServiceConversationType,
)


class ConversationSummary(PydanticBaseModel):
    """AI-generated conversation summary.

    AI-generated summary capturing the essence of a conversation including key discussion points,
    required follow-up actions, and overall sentiment analysis. Generated post-conversation for
    reporting, analytics, and customer service quality assurance.

    Architecture Context:
        - Generated By: Post-conversation AI summarization pipeline
        - Used For: Analytics dashboards, quality assurance, and customer service reports
        - Stored In: ServiceConversationConfig.conversation_summary field (optional)
    """

    model_config = ConfigDict(
        validate_by_name=True,
        validate_by_alias=True,
        use_enum_values=True,
    )

    summary: str = Field(
        ...,
        description="Concise 1-3 sentence overview of the entire conversation capturing the main topics discussed, issues addressed, and final outcomes"
    )
    key_points: List[str] = Field(
        ...,
        description="Array of bullet points highlighting important discussion topics, decisions made, information exchanged, or concerns raised during the conversation"
    )
    action_items: List[str] = Field(
        ...,
        description="Array of specific follow-up tasks, commitments, or next steps identified during the conversation (e.g., 'Send pricing quote by Friday', 'Schedule technical support callback', 'Update account information')"
    )
    sentiment: ConversationSummarySentiment = Field(
        ...,
        description="Overall emotional tone and customer satisfaction level detected from the conversation analysis (POSITIVE: satisfied/happy, NEGATIVE: frustrated/upset, NEUTRAL: informational, MIXED: varying emotions)"
    )


class Message(PydanticBaseModel):
    """Lightweight message representation used within conversation configurations.

    Simplified version compared to the full ConversationMessageSchema for efficient storage and
    retrieval in conversation message arrays.

    Architecture Context:
        - Used In: Conversation message arrays for quick access
        - Relationship: Simplified version of full message schemas (UserChatMessage, AssistantChatMessage, etc.)
        - Storage: Embedded within conversation documents for fast message loading
    """

    model_config = ConfigDict(
        validate_by_name=True,
        validate_by_alias=True,
        use_enum_values=True,
    )

    id: Optional[str] = Field(
        None,
        description="Optional internal database ID for the message record, auto-generated by the storage system"
    )
    message_id: str = Field(
        ...,
        description="Unique identifier for this message used for deduplication, reference tracking, and message threading (typically UUID format)",
        alias="messageId"
    )
    content: str = Field(
        ...,
        description="Text content of the message sent by the user or assistant, may include plain text or formatted content depending on channel capabilities"
    )
    message_type: MessageType = Field(
        ...,
        description="Type of message sender indicating who sent this message: 'user' for customer messages, 'assistant' for AI agent responses"
    )
    timestamp: datetime = Field(
        ...,
        description="JavaScript Date object representing the exact time when the message was created and sent in the conversation"
    )
    metadata: Dict[str, Any] = Field(
        ...,
        description="Additional message-specific metadata as key-value pairs including attachments, formatting, media URLs, delivery status, read receipts, or channel-specific attributes"
    )
    created_at: Optional[int] = Field(
        None,
        description="Unix timestamp in milliseconds when the message was created, used for chronological sorting and time-based filtering in queries"
    )


class ConversationStateHistory(PydanticBaseModel):
    """Conversation state history for tracking status changes.

    Audit trail recording each status transition throughout a conversation's lifecycle. Enables tracking
    conversation progression from initiation to completion, understanding conversation flow patterns, and
    analyzing resolution times.

    Architecture Context:
        - Used In: ServiceConversationConfig.state_history array
        - Purpose: Audit trail for status transitions and conversation lifecycle tracking
        - Analytics: Used for measuring average handling time, resolution rates, and conversation flow analysis

    Status Lifecycle:
        - ACTIVE: Conversation currently in progress with ongoing message exchange
        - COMPLETED: Conversation successfully concluded with issue resolved or information provided
        - FAILED: Conversation encountered errors or technical failures
        - ABANDONED: User left conversation without resolution
        - TRANSFERRED: Call transferred to human agent
    """

    model_config = ConfigDict(
        validate_by_name=True,
        validate_by_alias=True,
        use_enum_values=True,
    )

    status: ConversationStatus = Field(
        ...,
        description="The conversation status at this point in the lifecycle (ACTIVE: in progress, COMPLETED: successfully concluded, FAILED: encountered errors, ABANDONED: user left, TRANSFERRED: escalated to human)"
    )
    timestamp: int = Field(
        ...,
        description="Unix timestamp in milliseconds when this status was set and recorded in the conversation history"
    )
    reason: Optional[str] = Field(
        None,
        description="Optional human-readable explanation for why the status changed (e.g., 'User requested transfer to billing', 'Timeout after 5 minutes of inactivity', 'Issue successfully resolved')"
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description="Additional context about the state change as key-value pairs including triggering events, system metrics, agent performance data, or escalation/transfer details"
    )


class CallTransfer(PydanticBaseModel):
    """Call transfer details for tracking call transfer in telephony conversations.

    Captures metadata about call transfers to human agents including transfer type, timing, destination,
    and outcome. Used for measuring transfer rates, analyzing escalation patterns, and tracking agent
    handoff performance in telephony deployments.

    Architecture Context:
        - Used In: ServiceConversationConfig.call_transfer field for telephony conversations
        - Triggered By: Agent detecting escalation keywords, user request, or configured transfer conditions
        - References: CallTransferConfig from agent configuration for transfer destinations
        - Analytics: Used for measuring AI containment rates and identifying improvement areas

    Transfer Types:
        - blind: Immediate unattended transfer without agent introduction (faster, no screening)
        - warm: Attended transfer where agent is briefed before caller is connected (professional, allows declining)

    Transfer Lifecycle:
        - pending: Transfer initiated, waiting for recipient to answer
        - completed: Transfer successful, caller connected to human agent
        - failed: Transfer failed due to busy line, no answer, or technical error
        - returned: Call returned to AI agent after human agent consultation
    """

    model_config = ConfigDict(
        validate_by_name=True,
        validate_by_alias=True,
        use_enum_values=True,
    )

    transfer_type: Optional[Literal["blind", "warm"]] = Field(
        None,
        description="Type of call transfer: 'blind' for immediate unattended transfer without introduction (faster), 'warm' for attended transfer with agent briefing before connection (professional, allows screening)"
    )
    transfer_target: str = Field(
        ...,
        description="Target phone number for the call transfer in E.164 format (e.g., '+12125551234') or internal extension identifier, must match CallTransferConfig.transfer_number"
    )
    transfer_initiated_at: Optional[int] = Field(
        None,
        description="Unix timestamp in milliseconds when the transfer was initiated by the AI agent, used for measuring time-to-transfer and transfer latency"
    )
    transfer_completed_at: Optional[int] = Field(
        None,
        description="Unix timestamp in milliseconds when the transfer was successfully completed with caller connected to human agent, used for calculating transfer duration"
    )
    transfer_status: Literal["pending", "completed", "failed", "returned"] = Field(
        ...,
        description="Current status of the call transfer (pending: initiated awaiting answer, completed: successful connection, failed: no answer/busy/error, returned: call returned to AI after consultation)"
    )
    transfer_reason: Optional[str] = Field(
        None,
        description="Reason for the transfer as extracted from the conversation context (e.g., 'Billing inquiry requiring account access', 'Customer requested human agent', 'Technical issue beyond AI scope')"
    )


class BaseConversationConfig(PydanticBaseModel):
    """Base conversation configuration schema.

    Foundation schema for all conversation types capturing the essential attributes of an interaction session
    between a user and an AI agent. Conversations link to deployment configurations, track message history,
    monitor status progression, and collect voice processing metadata for telephony interactions.

    Architecture Context:
        - Relationship to Deployments: N:1 - Multiple conversations use one deployment configuration
        - Relationship to Projects: N:1 - Conversations are scoped to projects for organizational grouping
        - Relationship to Channels: N:1 - Multiple conversations occur through one channel
        - Extended By: ServiceConversationConfig adds conversation-specific fields (id, call transfer, etc.)
        - Storage: Primary conversation record with embedded messages for performance

    Conversation Types:
        - OTT_CHAT: Over-the-top chat (web, mobile app messaging)
        - TELEPHONY_CALL: Voice phone calls with STT/TTS processing
        - SMS: Text message conversations
        - EMAIL: Email-based interactions
        - WHATSAPP: WhatsApp messaging conversations
    """

    model_config = ConfigDict(
        validate_by_name=True,
        validate_by_alias=True,
        use_enum_values=True,
    )

    channel_id: str = Field(
        ...,
        description="ID of the deployment channel through which this conversation is conducted (references DeploymentChannel for phone, SMS, web, or email configuration)"
    )
    organization_id: str = Field(
        ...,
        description="ID of the organization that owns this conversation for multi-tenant data isolation, access control, and billing attribution"
    )
    project_id: str = Field(
        ...,
        description="ID of the project this conversation is associated with for organizational grouping, reporting, and access control (N:1 relationship with Project)"
    )
    deployment_config_id: str = Field(
        ...,
        description="ID of the deployment configuration that powers this conversation including agent, instruction, and channel settings (N:1 relationship with DeploymentConfiguration)"
    )
    channel_identifier: str = Field(
        ...,
        description="Unique identifier for the specific communication endpoint: phone number in E.164 format (+12125551234), chat widget ID, email address, or WhatsApp number"
    )
    instruction_config_id: Optional[str] = Field(
        None,
        description="Optional ID of the instruction configuration overriding deployment defaults for conversation-specific behavior or A/B testing (references InstructionConfiguration)"
    )
    partner_user_id: Optional[str] = Field(
        None,
        description="External partner or user identifier from integrated systems (CRM, help desk, e-commerce) for cross-platform user tracking and unified customer view"
    )
    conversation_type: ServiceConversationType = Field(
        ...,
        description="Type of conversation defining the communication channel and interaction mode (OTT_CHAT: web/mobile chat, TELEPHONY_CALL: voice, SMS: text, EMAIL: email, WHATSAPP: WhatsApp)"
    )
    model_id: Optional[str] = Field(
        None,
        description="AI model ID used for this conversation, may override deployment configuration model for A/B testing, specialized scenarios, or model version upgrades (references WiilSupportModel)"
    )
    user_id: Optional[int] = Field(
        None,
        description="Internal platform user ID for authenticated users enabling personalized conversations and user-specific history, null for anonymous or guest interactions"
    )
    created_at: Optional[int] = Field(
        None,
        description="Unix timestamp in milliseconds when conversation was initiated by user or outbound campaign (default: current time, used for chronological sorting)"
    )
    messages: Optional[List["ConversationMessage"]] = Field(
        None,
        description="Array of messages exchanged in this conversation embedded for quick access without separate database queries (includes user and assistant messages with metadata)"
    )
    is_campaign: bool = Field(
        False,
        description="Flag indicating if this conversation is part of a marketing or outbound campaign (true) or an inbound customer-initiated interaction (false, default)"
    )
    customer_id: Optional[str] = Field(
        None,
        description="Customer or contact ID from CRM or external system for customer relationship tracking, conversation history aggregation, and personalization"
    )
    status: Optional[ConversationStatus] = Field(
        None,
        description="Current operational status of the conversation (ACTIVE: ongoing, COMPLETED: concluded successfully, FAILED: errors, ABANDONED: user left, TRANSFERRED: escalated to human)"
    )
    duration_in_seconds: int = Field(
        15,
        description="Duration of the conversation in seconds for billing calculations, analytics reporting, and average handling time (AHT) metrics (default: 15 for minimum billing)",
        alias="durationInSeconds"
    )
    stt_model_id: Optional[str] = Field(
        None,
        description="Speech-to-Text model ID used for voice conversations to transcribe user speech into text (e.g., 'whisper-v3', 'google-stt-enhanced', references WiilSupportModel)"
    )
    tts_model_id: Optional[str] = Field(
        None,
        description="Text-to-Speech model ID used for voice conversations to synthesize agent text responses into natural speech (e.g., 'eleven-labs-v2', 'azure-neural-tts', references WiilSupportModel)"
    )
    conversation_summary: Optional[ConversationSummary] = Field(
        None,
        description="Optional AI-generated summary of the conversation including key discussion points, action items, and sentiment analysis (populated post-conversation for reporting and QA)",
        alias="conversationSummary"
    )
    created_day: Optional[str] = Field(
        None,
        description="The day the conversation was created in YYYY-MM-DD ISO format for efficient daily aggregation queries, analytics partitioning, and time-series reporting"
    )
    state_history: Optional[List[ConversationStateHistory]] = Field(
        None,
        description="Historical audit trail of status changes throughout the conversation lifecycle for flow analysis, troubleshooting, and measuring time-to-resolution"
    )
    updated_at: Optional[int] = Field(
        None,
        description="Unix timestamp in milliseconds when conversation was last modified (message added, status changed, summary generated, metadata updated) for change tracking"
    )
    deleted_at: Optional[int] = Field(
        None,
        description="Unix timestamp in milliseconds when conversation was soft-deleted for data retention compliance, null if active (enables GDPR right-to-be-forgotten while preserving analytics)"
    )


class ServiceConversationConfig(BaseModel):
    """Service conversation configuration schema.

    Complete conversation record extending base configuration with conversation-specific identifiers,
    provider metadata, call direction, recording URLs, and transfer details. This is the primary
    schema used for storing and retrieving conversation records in the system.

    Architecture Context:
        - Extends: BaseModel (has id, created_at, updated_at) with conversation-specific fields
        - Storage: Primary conversation entity in database with unique id
        - Provider Integration: Tracks external provider IDs for email services, telephony platforms
        - Call Recordings: resource_url links to call recording storage for compliance and quality assurance

    Use Cases:
        - Creating new conversations for inbound/outbound interactions
        - Retrieving conversation history with full message arrays
        - Analyzing call recordings and transfer patterns
        - Integrating with external email providers (Gmail, Outlook, etc.)
    """

    model_config = ConfigDict(
        validate_by_name=True,
        validate_by_alias=True,
        use_enum_values=True,
    )

    # All fields from BaseConversationConfig
    channel_id: str = Field(
        ...,
        description="ID of the deployment channel through which this conversation is conducted (references DeploymentChannel for phone, SMS, web, or email configuration)"
    )
    organization_id: str = Field(
        ...,
        description="ID of the organization that owns this conversation for multi-tenant data isolation, access control, and billing attribution"
    )
    project_id: str = Field(
        ...,
        description="ID of the project this conversation is associated with for organizational grouping, reporting, and access control (N:1 relationship with Project)"
    )
    deployment_config_id: str = Field(
        ...,
        description="ID of the deployment configuration that powers this conversation including agent, instruction, and channel settings (N:1 relationship with DeploymentConfiguration)"
    )
    channel_identifier: str = Field(
        ...,
        description="Unique identifier for the specific communication endpoint: phone number in E.164 format (+12125551234), chat widget ID, email address, or WhatsApp number"
    )
    instruction_config_id: Optional[str] = Field(
        None,
        description="Optional ID of the instruction configuration overriding deployment defaults for conversation-specific behavior or A/B testing (references InstructionConfiguration)"
    )
    partner_user_id: Optional[str] = Field(
        None,
        description="External partner or user identifier from integrated systems (CRM, help desk, e-commerce) for cross-platform user tracking and unified customer view"
    )
    conversation_type: ServiceConversationType = Field(
        ...,
        description="Type of conversation defining the communication channel and interaction mode (OTT_CHAT: web/mobile chat, TELEPHONY_CALL: voice, SMS: text, EMAIL: email, WHATSAPP: WhatsApp)"
    )
    model_id: Optional[str] = Field(
        None,
        description="AI model ID used for this conversation, may override deployment configuration model for A/B testing, specialized scenarios, or model version upgrades (references WiilSupportModel)"
    )
    user_id: Optional[int] = Field(
        None,
        description="Internal platform user ID for authenticated users enabling personalized conversations and user-specific history, null for anonymous or guest interactions"
    )
    messages: Optional[List["ConversationMessage"]] = Field(
        None,
        description="Array of messages exchanged in this conversation embedded for quick access without separate database queries (includes user and assistant messages with metadata)"
    )
    is_campaign: bool = Field(
        False,
        description="Flag indicating if this conversation is part of a marketing or outbound campaign (true) or an inbound customer-initiated interaction (false, default)"
    )
    customer_id: Optional[str] = Field(
        None,
        description="Customer or contact ID from CRM or external system for customer relationship tracking, conversation history aggregation, and personalization"
    )
    status: Optional[ConversationStatus] = Field(
        None,
        description="Current operational status of the conversation (ACTIVE: ongoing, COMPLETED: concluded successfully, FAILED: errors, ABANDONED: user left, TRANSFERRED: escalated to human)"
    )
    duration_in_seconds: int = Field(
        15,
        description="Duration of the conversation in seconds for billing calculations, analytics reporting, and average handling time (AHT) metrics (default: 15 for minimum billing)",
        alias="durationInSeconds"
    )
    stt_model_id: Optional[str] = Field(
        None,
        description="Speech-to-Text model ID used for voice conversations to transcribe user speech into text (e.g., 'whisper-v3', 'google-stt-enhanced', references WiilSupportModel)"
    )
    tts_model_id: Optional[str] = Field(
        None,
        description="Text-to-Speech model ID used for voice conversations to synthesize agent text responses into natural speech (e.g., 'eleven-labs-v2', 'azure-neural-tts', references WiilSupportModel)"
    )
    conversation_summary: Optional[ConversationSummary] = Field(
        None,
        description="Optional AI-generated summary of the conversation including key discussion points, action items, and sentiment analysis (populated post-conversation for reporting and QA)",
        alias="conversationSummary"
    )
    created_day: Optional[str] = Field(
        None,
        description="The day the conversation was created in YYYY-MM-DD ISO format for efficient daily aggregation queries, analytics partitioning, and time-series reporting"
    )
    state_history: Optional[List[ConversationStateHistory]] = Field(
        None,
        description="Historical audit trail of status changes throughout the conversation lifecycle for flow analysis, troubleshooting, and measuring time-to-resolution"
    )
    deleted_at: Optional[int] = Field(
        None,
        description="Unix timestamp in milliseconds when conversation was soft-deleted for data retention compliance, null if active (enables GDPR right-to-be-forgotten while preserving analytics)"
    )

    # Additional fields specific to ServiceConversationConfig
    record_id: Optional[str] = Field(
        None,
        description="Optional external record ID for integration with partner systems, CRM platforms, or help desk software for conversation linkage and data synchronization"
    )
    provider_message_id: Optional[str] = Field(
        None,
        description="Provider-specific email message ID from email service providers (Gmail message ID, Outlook message ID, SendGrid ID) for email conversation tracking and threading"
    )
    direction: Optional[ConversationDirection] = Field(
        None,
        description="Direction of the telephony call: 'inbound' for customer-initiated calls, 'outbound' for agent-initiated or campaign calls (null for non-voice channels like chat/email)"
    )
    resource_url: Optional[str] = Field(
        None,
        description="Resource URL for the call recording or conversation details from telephony provider (SignalWire recording URL, Twilio media URL) for compliance, quality assurance, and dispute resolution"
    )
    call_transfer: Optional[CallTransfer] = Field(
        None,
        description="Call transfer details if the conversation was transferred to a human agent including transfer type, destination, timing, and outcome (null if no transfer occurred)"
    )


class DecommissionConfig(PydanticBaseModel):
    """Decommission configuration schema.

    Request payload for decommissioning and shutting down active conversation services. Used for
    gracefully terminating conversation sessions, cleaning up resources, and releasing telephony
    connections when deployments are disabled or conversations are force-closed.

    Architecture Context:
        - Used For: Graceful shutdown of active conversation sessions
        - Triggered By: Admin actions, deployment deactivation, or timeout policies
        - Effects: Releases telephony resources, closes WebSocket connections, archives conversation

    Use Cases:
        - Emergency shutdown of misbehaving conversation sessions
        - Cleanup when deployments are deactivated
        - Forced conversation termination for policy violations
    """

    model_config = ConfigDict(
        validate_by_name=True,
        validate_by_alias=True,
        use_enum_values=True,
    )

    decommission_service_id: str = Field(
        ...,
        description="Service ID of the active conversation session to decommission and shut down gracefully, releases resources and closes all active connections"
    )


# Forward reference resolution
from wiil.models.conversation.conversation_message import ConversationMessage  # noqa: E402

BaseConversationConfig.model_rebuild()
ServiceConversationConfig.model_rebuild()
